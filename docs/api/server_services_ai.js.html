<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: server/services/ai.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: server/services/ai.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview AI Service - Core AI routing and clinical analysis functions.
 *
 * This module handles all AI provider interactions, including:
 * - Multi-provider routing with automatic failover (DeepSeek, OpenAI, Anthropic, etc.)
 * - Clinical guideline relevance analysis
 * - Practice point compliance checking
 * - Suggestion generation and refinement
 * - Sense-checking for temporal/logical consistency
 *
 * @module server/services/ai
 * @requires axios
 * @requires string-similarity
 * @requires ../config/firebase
 * @requires ../config/logger
 * @requires ../config/constants
 * @requires ./preferences
 */

const axios = require('axios');
const stringSimilarity = require('string-similarity');
const { db, admin } = require('../config/firebase');
const { debugLog } = require('../config/logger');
const { AI_PROVIDER_PREFERENCE, AI_MODEL_REGISTRY } = require('../config/constants');
const {
    getUserAIPreference,
    getProviderFromModel,
    getUserModelPreferences,
    getNextAvailableProvider,
    getUserChunkDistributionProviders
} = require('./preferences');

const SEQUENTIAL_LLM_CHAIN = AI_PROVIDER_PREFERENCE.map(p => ({
    model: p.model,
    displayName: `${p.name} (${p.model})`,
    provider: p.name,
    cost: p.costPer1kTokens
}));

/**
 * Creates an AI prompt for analyzing guideline relevance to a clinical case.
 *
 * @param {string} transcript - The clinical note/transcript text
 * @param {Array&lt;Object>} guidelinesChunk - Array of guideline objects to evaluate
 * @param {string} guidelinesChunk[].id - Unique guideline identifier
 * @param {string} guidelinesChunk[].title - Guideline title
 * @param {string} [guidelinesChunk[].summary] - Optional guideline summary
 * @param {string[]} [guidelinesChunk[].keywords] - Optional keywords for matching
 * @returns {string} Formatted prompt for the AI model
 */
function createPromptForChunk(transcript, guidelinesChunk) {
    const guidelinesText = guidelinesChunk.map(g => {
        let guidelineInfo = `[${g.id}] ${g.title}`;
        if (g.summary &amp;&amp; g.summary.trim()) {
            guidelineInfo += `\nSummary: ${g.summary.trim()}`;
        }
        if (g.keywords &amp;&amp; Array.isArray(g.keywords) &amp;&amp; g.keywords.length > 0) {
            guidelineInfo += `\nKeywords: ${g.keywords.slice(0, 10).join(', ')}`;
        }
        return guidelineInfo;
    }).join('\n\n---\n\n');

    return `You are a medical expert analyzing a clinical case to identify the most relevant medical guidelines. Your task is to categorize each guideline by its clinical relevance to the specific patient scenario.

CLINICAL CASE:
${transcript}

AVAILABLE GUIDELINES:
${guidelinesText}

ANALYSIS INSTRUCTIONS:
1. Carefully read the clinical case and identify the key clinical issues, patient demographics, and medical context
2. For each guideline, consider:
   - Direct relevance to the patient's primary presenting conditions
   - Applicability to the patient's specific demographics (age, pregnancy status, etc.)
   - Relevance to secondary issues or comorbidities mentioned
   - Potential value for differential diagnosis or management planning
   - Appropriateness for the clinical setting and care level described

RELEVANCE SCORING (0.0-1.0):
- 0.9-1.0: Directly addresses primary clinical issues and patient context
- 0.7-0.89: Highly relevant to primary or important secondary issues  
- 0.5-0.69: Moderately relevant to secondary issues or differential diagnosis
- 0.2-0.49: Limited relevance, may provide background information
- 0.0-0.19: Minimal or no relevance to this specific case

RESPONSE FORMAT (JSON only):
{
  "mostRelevant": [{"id": "guideline_id", "title": "guideline_title", "relevance": "0.XX"}],
  "potentiallyRelevant": [{"id": "guideline_id", "title": "guideline_title", "relevance": "0.XX"}],
  "lessRelevant": [{"id": "guideline_id", "title": "guideline_title", "relevance": "0.XX"}],
  "notRelevant": [{"id": "guideline_id", "title": "guideline_title", "relevance": "0.XX"}]
}

Provide ONLY the JSON response with no additional text or explanation.`;
}

/**
 * Merges results from multiple guideline chunk analyses into a single categorized result.
 *
 * Re-categorizes all guidelines by relevance score thresholds:
 * - mostRelevant: score >= 0.8
 * - potentiallyRelevant: score >= 0.6
 * - lessRelevant: score >= 0.3
 * - notRelevant: score &lt; 0.3
 *
 * @param {Array&lt;Object>} chunkResults - Array of chunk analysis results
 * @param {Object} chunkResults[].categories - Categorized guidelines from each chunk
 * @returns {Object} Merged and re-sorted categories
 * @returns {Array} returns.mostRelevant - Highly relevant guidelines
 * @returns {Array} returns.potentiallyRelevant - Moderately relevant guidelines
 * @returns {Array} returns.lessRelevant - Low relevance guidelines
 * @returns {Array} returns.notRelevant - Irrelevant guidelines
 */
function mergeChunkResults(chunkResults) {
    const merged = {
        mostRelevant: [],
        potentiallyRelevant: [],
        lessRelevant: [],
        notRelevant: []
    };

    chunkResults.forEach(result => {
        if (result &amp;&amp; result.categories) {
            Object.keys(merged).forEach(category => {
                if (result.categories[category] &amp;&amp; Array.isArray(result.categories[category])) {
                    merged[category].push(...result.categories[category]);
                }
            });
        }
    });

    const allGuidelines = [];
    Object.keys(merged).forEach(category => {
        merged[category].forEach(guideline => {
            allGuidelines.push({ ...guideline, originalCategory: category });
        });
    });

    merged.mostRelevant = [];
    merged.potentiallyRelevant = [];
    merged.lessRelevant = [];
    merged.notRelevant = [];

    allGuidelines.forEach(guideline => {
        const score = parseFloat(guideline.relevance) || 0;
        if (score >= 0.8) {
            merged.mostRelevant.push(guideline);
        } else if (score >= 0.6) {
            merged.potentiallyRelevant.push(guideline);
        } else if (score >= 0.3) {
            merged.lessRelevant.push(guideline);
        } else {
            merged.notRelevant.push(guideline);
        }
    });

    Object.keys(merged).forEach(category => {
        merged[category].sort((a, b) => {
            const aScore = parseFloat(a.relevance) || 0;
            const bScore = parseFloat(b.relevance) || 0;
            return bScore - aScore;
        });
    });

    return merged;
}

/**
 * Parses and normalizes AI response for a guideline chunk analysis.
 *
 * Handles various response formats and uses fuzzy matching to resolve
 * guideline titles back to their IDs when the AI returns titles instead.
 *
 * @param {string} responseContent - Raw AI response text (may contain JSON)
 * @param {Array&lt;Object>} [originalChunk=[]] - Original guidelines for ID resolution
 * @returns {Object} Parsing result
 * @returns {boolean} returns.success - Whether parsing succeeded
 * @returns {Object} [returns.categories] - Categorized guidelines if successful
 * @returns {string} [returns.error] - Error message if parsing failed
 */
function parseChunkResponse(responseContent, originalChunk = []) {
    try {
        let cleanContent = responseContent.trim();
        const jsonMatch = cleanContent.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/i);
        if (jsonMatch) cleanContent = jsonMatch[1];

        const parsed = JSON.parse(cleanContent);
        const categoryRoot = (parsed &amp;&amp; typeof parsed === 'object' &amp;&amp; parsed.categories &amp;&amp; typeof parsed.categories === 'object')
            ? parsed.categories
            : parsed;

        const cleanedCategories = {
            mostRelevant: [],
            potentiallyRelevant: [],
            lessRelevant: [],
            notRelevant: []
        };

        const byId = new Map(originalChunk.map(g => [g.id, g]));
        const originalTitles = originalChunk.map(g => g.title);

        const normaliseItem = (item) => {
            if (!item) return null;
            if (typeof item === 'string') return { id: item, relevance: '0.5' };
            if (typeof item !== 'object') return null;
            return { id: item.id, title: item.title, relevance: item.relevance };
        };

        const extractCategoryArray = (root, key) => {
            const v = root ? root[key] : null;
            return Array.isArray(v) ? v : [];
        };

        for (const category of Object.keys(cleanedCategories)) {
            const arr = extractCategoryArray(categoryRoot, category);
            cleanedCategories[category] = arr.map(raw => {
                const item = normaliseItem(raw) || {};
                const relevance = item.relevance || '0.5';

                if (item.id &amp;&amp; byId.has(item.id)) return { id: item.id, relevance };

                if (item.title) {
                    const { bestMatch } = stringSimilarity.findBestMatch(item.title, originalTitles);
                    if (bestMatch.rating > 0.7) {
                        const guideline = originalChunk.find(g => g.title === bestMatch.target);
                        if (guideline) return { id: guideline.id, relevance };
                    }
                }
                return { id: item.id || 'unknown-id', relevance: item.relevance || '0.0' };
            });
        }
        return { success: true, categories: cleanedCategories };
    } catch (jsonError) {
        debugLog('[DEBUG] JSON parsing failed:', jsonError.message);
        // Fallback to text parsing (omitted for brevity in this replace, assuming JSON reliability or acceptable fallback)
        return { success: false, error: jsonError.message };
    }
}

/**
 * Formats chat messages for different AI provider APIs.
 *
 * Each provider has slightly different message format requirements:
 * - OpenAI/DeepSeek/Mistral/Groq: Standard {role, content} format
 * - Anthropic: System messages converted to user messages with prefix
 * - Gemini: Uses {role, parts: [{text}]} format
 *
 * @param {Array&lt;Object>} messages - Array of chat messages
 * @param {string} messages[].role - Message role ('system', 'user', 'assistant')
 * @param {string} messages[].content - Message content
 * @param {string} provider - Target provider name
 * @returns {Array&lt;Object>} Provider-formatted messages
 */
function formatMessagesForProvider(messages, provider) {
    switch (provider) {
        case 'OpenAI': return messages;
        case 'DeepSeek': return messages.map(msg => ({ role: msg.role, content: msg.content }));
        case 'Anthropic': return messages.map(msg => ({ role: msg.role === 'system' ? 'user' : msg.role, content: msg.role === 'system' ? `System: ${msg.content}` : msg.content }));
        case 'Mistral': return messages.map(msg => ({ role: msg.role, content: msg.content }));
        case 'Gemini': return messages.map(msg => ({ role: msg.role === 'system' ? 'user' : msg.role, parts: [{ text: msg.content }] }));
        case 'Groq': return messages.map(msg => ({ role: msg.role, content: msg.content }));
        default: return messages;
    }
}

/**
 * Sends a prompt to an AI provider with automatic failover and logging.
 *
 * This is the core AI communication function. It handles:
 * - Provider selection based on model name or user preferences
 * - Automatic failover when API keys are missing
 * - Message formatting for different providers
 * - Response logging to Firestore for analytics
 *
 * @async
 * @param {string|Array&lt;Object>} prompt - Text prompt or array of chat messages
 * @param {string} [model='deepseek-chat'] - Model identifier (determines provider)
 * @param {string|null} [systemPrompt=null] - System prompt (if prompt is string)
 * @param {string|null} [userId=null] - User ID for preference lookup and logging
 * @param {number} [temperature=0.7] - Sampling temperature (0-1)
 * @param {number} [timeoutMs=120000] - Request timeout in milliseconds
 * @param {boolean} [skipUserPreference=false] - Skip user's model preferences
 * @param {number} [maxTokens=4000] - Maximum tokens in response
 * @returns {Promise&lt;Object>} AI response object
 * @returns {string} returns.content - Generated text content
 * @returns {string} returns.ai_provider - Provider that handled request
 * @returns {string} returns.ai_model - Model that was used
 * @returns {Object} returns.token_usage - Token usage statistics
 * @throws {Error} If no AI provider API keys are configured or request fails
 */
async function sendToAI(prompt, model = 'deepseek-chat', systemPrompt = null, userId = null, temperature = 0.7, timeoutMs = 120000, skipUserPreference = false, maxTokens = 4000) {
    let preferredProvider = 'DeepSeek';
    const sendToAIStartTime = Date.now();

    try {
        if (model.includes('deepseek')) preferredProvider = 'DeepSeek';
        else if (model.includes('claude') || model.includes('anthropic')) preferredProvider = 'Anthropic';
        else if (model.includes('mistral')) preferredProvider = 'Mistral';
        else if (model.includes('gemini')) preferredProvider = 'Gemini';
        else if (model.startsWith('grok-')) preferredProvider = 'Grok';
        else if (model.includes('gpt') &amp;&amp; !model.includes('gpt-oss')) preferredProvider = 'OpenAI';
        else if (model.includes('groq/') || model.includes('llama-3') || model.includes('llama-4') || model.includes('gpt-oss') || model.includes('kimi-k2') || model.includes('qwen')) preferredProvider = 'Groq';

        if (userId &amp;&amp; !skipUserPreference) {
            try {
                const userModelOrder = await getUserModelPreferences(userId);
                if (userModelOrder &amp;&amp; userModelOrder.length > 0) {
                    const firstPreferredModelId = userModelOrder[0];
                    const providerConfig = AI_PROVIDER_PREFERENCE.find(p => p.model === firstPreferredModelId);
                    if (providerConfig &amp;&amp; providerConfig.name !== preferredProvider) {
                        preferredProvider = providerConfig.name;
                        model = providerConfig.model;
                    }
                }
            } catch (error) { }
        }

        const availableKeys = {
            hasOpenAIKey: !!process.env.OPENAI_API_KEY,
            hasDeepSeekKey: !!process.env.DEEPSEEK_API_KEY,
            hasAnthropicKey: !!process.env.ANTHROPIC_API_KEY,
            hasMistralKey: !!process.env.MISTRAL_API_KEY,
            hasGeminiKey: !!process.env.GOOGLE_AI_API_KEY,
            hasGroqKey: !!process.env.GROQ_API_KEY,
            hasGrokKey: !!process.env.GROK_API_KEY
        };

        const hasCurrentProviderKey = availableKeys[`has${preferredProvider}Key`];
        if (!hasCurrentProviderKey) {
            let fallbackModelOrder = AI_PROVIDER_PREFERENCE.map(p => p.model);
            if (userId) {
                try {
                    const userModelOrder = await getUserModelPreferences(userId);
                    if (userModelOrder &amp;&amp; userModelOrder.length > 0) fallbackModelOrder = userModelOrder;
                } catch (e) { }
            }
            let nextProvider = null;
            const currentIndex = fallbackModelOrder.indexOf(model);
            for (let i = currentIndex + 1; i &lt; fallbackModelOrder.length; i++) {
                const modelId = fallbackModelOrder[i];
                const providerConfig = AI_PROVIDER_PREFERENCE.find(p => p.model === modelId);
                if (providerConfig &amp;&amp; availableKeys[`has${providerConfig.name}Key`]) {
                    nextProvider = providerConfig;
                    break;
                }
            }
            if (!nextProvider) {
                for (let i = 0; i &lt; currentIndex; i++) {
                    const modelId = fallbackModelOrder[i];
                    const providerConfig = AI_PROVIDER_PREFERENCE.find(p => p.model === modelId);
                    if (providerConfig &amp;&amp; availableKeys[`has${providerConfig.name}Key`]) {
                        nextProvider = providerConfig;
                        break;
                    }
                }
            }

            if (nextProvider) {
                preferredProvider = nextProvider.name;
                model = nextProvider.model;
            } else {
                throw new Error('No AI provider API keys configured');
            }
        }

        let messages = [];
        if (Array.isArray(prompt)) {
            messages = prompt;
        } else {
            if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
            messages.push({ role: 'user', content: prompt });
        }

        const formattedMessages = formatMessagesForProvider(messages, preferredProvider);
        let responseData, content, tokenUsage = {};

        if (preferredProvider === 'DeepSeek') {
            const response = await axios.post('https://api.deepseek.com/v1/chat/completions', { model, messages: formattedMessages, temperature, max_tokens: maxTokens }, { headers: { 'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`, 'Content-Type': 'application/json' }, timeout: timeoutMs });
            responseData = response.data;
            content = responseData.choices[0].message.content;
        } else if (preferredProvider === 'OpenAI') {
            const response = await axios.post('https://api.openai.com/v1/chat/completions', { model, messages: formattedMessages, temperature, max_tokens: maxTokens }, { headers: { 'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`, 'Content-Type': 'application/json' }, timeout: timeoutMs });
            responseData = response.data;
            content = responseData.choices[0].message.content;
        } else if (preferredProvider === 'Anthropic') {
            const response = await axios.post('https://api.anthropic.com/v1/messages', { model, messages: formattedMessages, max_tokens: maxTokens, temperature }, { headers: { 'x-api-key': process.env.ANTHROPIC_API_KEY, 'Content-Type': 'application/json', 'anthropic-version': '2023-06-01' }, timeout: timeoutMs });
            responseData = response.data;
            content = responseData.content[0].text;
        } else if (preferredProvider === 'Mistral') {
            const response = await axios.post('https://api.mistral.ai/v1/chat/completions', { model, messages: formattedMessages, temperature, max_tokens: maxTokens }, { headers: { 'Authorization': `Bearer ${process.env.MISTRAL_API_KEY}`, 'Content-Type': 'application/json' }, timeout: timeoutMs });
            responseData = response.data;
            content = responseData.choices[0].message.content;
        } else if (preferredProvider === 'Gemini') {
            const geminiMessages = formattedMessages.map(msg => ({ role: msg.role === 'user' ? 'user' : 'model', parts: msg.parts || [{ text: msg.content || '' }] }));
            const response = await axios.post(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`, { contents: geminiMessages, generationConfig: { temperature, maxOutputTokens: maxTokens } }, { headers: { 'Content-Type': 'application/json' }, params: { key: process.env.GOOGLE_AI_API_KEY }, timeout: timeoutMs });
            responseData = response.data;
            content = responseData.candidates?.[0]?.content?.parts?.[0]?.text || '';
        } else if (preferredProvider === 'Groq') {
            const response = await axios.post('https://api.groq.com/openai/v1/chat/completions', { model, messages: formattedMessages, temperature, max_tokens: maxTokens }, { headers: { 'Authorization': `Bearer ${process.env.GROQ_API_KEY}`, 'Content-Type': 'application/json' }, timeout: timeoutMs });
            responseData = response.data;
            content = responseData.choices[0].message.content;
        } else if (preferredProvider === 'Grok') {
            const response = await axios.post('https://api.x.ai/v1/chat/completions', { model, messages: formattedMessages, temperature, max_tokens: maxTokens }, { headers: { 'Authorization': `Bearer ${process.env.GROK_API_KEY}`, 'Content-Type': 'application/json' }, timeout: timeoutMs });
            responseData = response.data;
            content = responseData.choices[0].message.content;
        }

        if (responseData &amp;&amp; (responseData.usage || responseData.usageMetadata)) {
            const usage = responseData.usage || responseData.usageMetadata;
            tokenUsage = { prompt_tokens: usage.prompt_tokens || usage.promptTokenCount || 0, completion_tokens: usage.completion_tokens || usage.candidatesTokenCount || 0, total_tokens: usage.total_tokens || usage.totalTokenCount || 0 };
        }

        if (db) {
            const latencyMs = Date.now() - sendToAIStartTime;
            const promptStr = typeof prompt === 'string' ? prompt : JSON.stringify(prompt);
            db.collection('aiInteractions').add({
                timestamp: admin.firestore.FieldValue.serverTimestamp(),
                userId: userId || 'anonymous',
                provider: preferredProvider,
                model,
                endpoint: 'sendToAI',
                promptTokens: tokenUsage.prompt_tokens || 0,
                completionTokens: tokenUsage.completion_tokens || 0,
                totalTokens: tokenUsage.total_tokens || 0,
                latencyMs,
                success: true,
                promptLength: promptStr.length,
                responseLength: content?.length || 0,
                fullPrompt: promptStr.substring(0, 50000),
                fullResponse: content ? content.substring(0, 50000) : ''
            }).catch(err => console.error('Failed to log AI interaction:', err.message));
        }

        return { content: content, ai_provider: preferredProvider, ai_model: model, token_usage: tokenUsage };

    } catch (error) {
        console.error('Error in sendToAI:', error.message);
        throw new Error(`AI request failed: ${error.response?.data?.error?.message || error.message}`);
    }
}

/**
 * High-level AI routing function with simplified interface.
 *
 * Automatically selects the best provider based on user preferences
 * and available API keys. Use this for most AI interactions.
 *
 * @async
 * @param {string|Object} prompt - Text prompt or {messages, temperature} object
 * @param {string|null} [userId=null] - User ID for preference lookup
 * @param {string|null} [preferredProvider=null] - Override provider selection
 * @param {number} [maxTokens=4000] - Maximum tokens in response
 * @returns {Promise&lt;Object>} AI response (see sendToAI for structure)
 * @throws {Error} If AI request fails
 *
 * @example
 * // Simple text prompt
 * const result = await routeToAI('Summarize this clinical note', userId);
 *
 * @example
 * // With chat messages and custom temperature
 * const result = await routeToAI({
 *   messages: [
 *     { role: 'system', content: 'You are a clinical advisor.' },
 *     { role: 'user', content: 'Analyze this case...' }
 *   ],
 *   temperature: 0.3
 * }, userId);
 */
async function routeToAI(prompt, userId = null, preferredProvider = null, maxTokens = 4000) {
    try {
        const defaultProvider = AI_PROVIDER_PREFERENCE[0].name;
        let provider = preferredProvider || defaultProvider;

        if (!preferredProvider &amp;&amp; userId) {
            try {
                const userPreference = await getUserAIPreference(userId);
                if (userPreference) provider = userPreference;
            } catch (error) { console.error('[DEBUG] Error getting user AI preference:', error.message); }
        }

        let model;
        const modelConfig = AI_PROVIDER_PREFERENCE.find(p => p.model === provider);
        if (modelConfig) {
            model = provider;
            provider = modelConfig.name;
        } else {
            const map = { 'OpenAI': 'gpt-3.5-turbo', 'DeepSeek': 'deepseek-chat', 'Anthropic': 'claude-3-haiku-20240307', 'Mistral': 'mistral-large-latest', 'Gemini': 'gemini-2.5-flash', 'Groq': 'llama-3.3-70b-versatile' };
            model = map[provider] || 'deepseek-chat';
        }

        const skipUserPreference = !!preferredProvider;
        let result;
        if (typeof prompt === 'object' &amp;&amp; prompt.messages) {
            const temperature = prompt.temperature !== undefined ? prompt.temperature : 0.7;
            result = await sendToAI(prompt.messages, model, null, userId, temperature, 120000, skipUserPreference, maxTokens);
        } else {
            result = await sendToAI(prompt, model, null, userId, 0.7, 120000, skipUserPreference, maxTokens);
        }

        return result;
    } catch (error) {
        console.error('[DEBUG] Error in routeToAI:', error.message);
        throw error;
    }
}

/**
 * Checks clinical note compliance against practice points and suggests improvements.
 *
 * Evaluates whether the clinical note addresses each practice point and
 * categorizes them as compliant or non-compliant.
 *
 * @async
 * @param {string} clinicalNote - The clinical note text to evaluate
 * @param {Array&lt;Object>} importantPoints - Practice points to check against
 * @param {number} importantPoints[].originalIndex - Original index in full list
 * @param {string} importantPoints[].point - The practice point text
 * @param {string} userId - User ID for AI routing
 * @returns {Promise&lt;Object>} Compliance results
 * @returns {Array} returns.compliant - Indices of compliant points
 * @returns {Array} returns.nonCompliant - Indices of non-compliant points
 */
async function checkComplianceAndSuggest(clinicalNote, importantPoints, userId) {
    if (importantPoints.length === 0) return { compliant: [], nonCompliant: [] };
    const pointsList = importantPoints.map(p => `[${p.originalIndex}] ${p.point}`).join('\n');
    const prompts = global.prompts || require('../../prompts.json');
    const promptConfig = prompts['checkPracticePointCompliance'];
    const systemPrompt = promptConfig?.system_prompt || 'You are a clinical advisor. Return ONLY valid JSON - no markdown, no explanations.';
    const userPrompt = (promptConfig?.prompt || `CLINICAL NOTE:\n{{clinicalNote}}\n\nPRACTICE POINTS:\n{{pointsList}}\n\nFor each practice point, ask yourself: "Is this clinical note essentially compliant..."\n\nReturn JSON...`)
        .replace('{{clinicalNote}}', clinicalNote)
        .replace('{{pointsList}}', pointsList);
    const result = await routeToAI({ messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }] }, userId);
    try {
        return JSON.parse(result.content.trim().replace(/```json\n?|\n?```/g, ''));
    } catch (e) {
        return { compliant: [], nonCompliant: [] };
    }
}

/**
 * Filters practice points to identify those relevant to a clinical note.
 *
 * First-pass filter that identifies which practice points from a guideline
 * are applicable to the specific patient case.
 *
 * @async
 * @param {string} clinicalNote - The clinical note text
 * @param {Array&lt;string>} allPoints - All practice points from guidelines
 * @param {string} userId - User ID for AI routing
 * @returns {Promise&lt;Object>} Filter results
 * @returns {Array&lt;number>} returns.relevant - Indices of relevant points (1-based)
 * @returns {Object} returns.irrelevant - Map of irrelevant point indices to reasons
 */
async function filterRelevantPracticePoints(clinicalNote, allPoints, userId) {
    if (!allPoints || allPoints.length === 0) return { relevant: [], irrelevant: {} };
    const pointsList = allPoints.map((p, i) => `[${i + 1}] ${p}`).join('\n');
    const result = await routeToAI({
        messages: [{ role: 'system', content: 'You are a clinical advisor. Return ONLY valid JSON.' },
        { role: 'user', content: `Clinical Note:\n${clinicalNote}\n\nPoints:\n${pointsList}\n\nFilter relevant...` }]
    }, userId);
    try {
        return JSON.parse(result.content.trim().replace(/```json\n?|\n?```/g, ''));
    } catch (e) {
        return { relevant: allPoints.map((_, i) => i + 1), irrelevant: {} };
    }
}

/**
 * Filters relevant practice points to identify those with significant clinical impact.
 *
 * Second-pass filter that prioritizes practice points likely to have
 * meaningful impact on patient care.
 *
 * @async
 * @param {string} clinicalNote - The clinical note text
 * @param {Array&lt;Object>} relevantPoints - Pre-filtered relevant points
 * @param {number} relevantPoints[].originalIndex - Original index in full list
 * @param {string} relevantPoints[].point - The practice point text
 * @param {string} userId - User ID for AI routing
 * @returns {Promise&lt;Object>} Filter results
 * @returns {Array&lt;number>} returns.important - Indices of important points
 * @returns {Object} returns.unimportant - Map of unimportant indices to reasons
 */
async function filterImportantPracticePoints(clinicalNote, relevantPoints, userId) {
    if (relevantPoints.length === 0) return { important: [], unimportant: {} };
    const pointsList = relevantPoints.map(p => `[${p.originalIndex}] ${p.point}`).join('\n');
    const messages = [{ role: 'system', content: 'You are a clinical advisor. Return ONLY valid JSON.' }, { role: 'user', content: `Clinical Note:\n${clinicalNote}\n\nPoints:\n${pointsList}\n\nDetermine if each practice point is likely to have significant impact...` }];
    const result = await routeToAI({ messages }, userId);
    try {
        return JSON.parse(result.content.trim().replace(/```json\n?|\n?```/g, ''));
    } catch (e) {
        return { important: relevantPoints.map(p => p.originalIndex), unimportant: {} };
    }
}

/**
 * Loads accumulated learning/interpretation hints for a guideline from Firestore.
 *
 * The learning system stores insights from previous analysis attempts,
 * which helps improve future AI interpretations of the same guideline.
 *
 * @async
 * @param {string} guidelineId - The guideline document ID
 * @returns {Promise&lt;Object|null>} Learning data or null if not found
 * @returns {string} returns.learningText - Accumulated learning prose
 * @returns {number} returns.version - Learning version number
 */
async function loadGuidelineLearning(guidelineId) {
    try {
        const learningDoc = await db.collection('guidelines').doc(guidelineId).collection('metadata').doc('interpretationHints').get();
        if (!learningDoc.exists) return null;
        const data = learningDoc.data();
        if (data.learningText) return { learningText: data.learningText, version: data.version || 1 };
        if (data.hints &amp;&amp; data.hints.length > 0) return { learningText: data.hints.map(h => h.hint).join(' '), version: 0 };
        return null;
    } catch (error) {
        return null;
    }
}
const loadGuidelineHints = loadGuidelineLearning;

/**
 * Formats accumulated learning into a prompt section for AI context.
 *
 * @param {Object|null} learning - Learning object from loadGuidelineLearning
 * @param {string} learning.learningText - The learning content
 * @returns {string} Formatted prompt section or empty string
 */
function formatLearningForPrompt(learning) {
    if (!learning || !learning.learningText) return '';
    return `\n\nIMPORTANT - ACCUMULATED LEARNING FROM PREVIOUS ATTEMPTS:\nThe following insights have been learned from previous AI attempts to analyse this guideline. Apply these lessons:\n\n${learning.learningText}\n`;
}

/**
 * Analyzes a clinical note against a specific guideline to generate suggestions.
 *
 * Two-step process:
 * 1. Identifies gaps in care (guideline recommendations not covered)
 * 2. Enriches suggestions with patient context and reasoning
 *
 * @async
 * @param {string} clinicalNote - The clinical note text
 * @param {string} guidelineContent - Full text content of the guideline
 * @param {string} guidelineTitle - Title of the guideline
 * @param {string} userId - User ID for AI routing
 * @param {string|null} [guidelineId=null] - Guideline ID for loading learning hints
 * @param {string|null} [targetModel=null] - Specific model to use
 * @returns {Promise&lt;Object>} Analysis results
 * @returns {Object} returns.patientContext - Extracted patient demographics/context
 * @returns {Array&lt;Object>} returns.suggestions - Clinical suggestions
 * @returns {string} returns.suggestions[].suggestion - The suggestion text
 * @returns {string} returns.suggestions[].priority - 'high', 'medium', or 'low'
 * @returns {string} returns.suggestions[].why - Reasoning for the suggestion
 * @returns {string} returns.suggestions[].verbatimQuote - Relevant guideline quote
 * @returns {Array&lt;string>} returns.alreadyCompliant - Points already addressed
 */
async function analyzeGuidelineForPatient(clinicalNote, guidelineContent, guidelineTitle, userId, guidelineId = null, targetModel = null) {
    let hintsText = '';
    if (guidelineId) {
        const learning = await loadGuidelineLearning(guidelineId);
        if (learning) hintsText = formatLearningForPrompt(learning);
    }

    const step1SystemPrompt = `You are a clinical advisor. Your job is to identify GAPS in care based on the provided clinical note and guideline. Identify any guideline recommendations NOT covered by the clinical note. Return ONLY valid JSON with this structure: { "suggestions": [{ "suggestion": "Concise, actionable advice", "priority": "high|medium|low", "reasoning": "Brief explanation" }] }`;
    const step1UserPrompt = `CLINICAL NOTE:\n${clinicalNote}\n\nGUIDELINE TITLE: ${guidelineTitle}\n\nGUIDELINE CONTENT:\n${guidelineContent}\n\n${hintsText ? `\nPREVIOUS FEEDBACK:\n${hintsText}\n` : ''}\n\nTASK: Identify any guideline recommendations NOT covered...`;
    const messagesStep1 = [{ role: 'system', content: step1SystemPrompt }, { role: 'user', content: step1UserPrompt }];
    const resultStep1 = await routeToAI({ messages: messagesStep1 }, userId, targetModel);

    if (!resultStep1 || !resultStep1.content) return { patientContext: {}, suggestions: [], alreadyCompliant: [] };

    let initialSuggestions = [];
    try {
        const parsed = JSON.parse(resultStep1.content.trim().replace(/```json\n?|\n?```/g, ''));
        initialSuggestions = parsed.suggestions || [];
    } catch (e) { return { patientContext: {}, suggestions: [], alreadyCompliant: [] }; }

    if (initialSuggestions.length === 0) return { patientContext: {}, suggestions: [], alreadyCompliant: [] };

    const step2SystemPrompt = `You are a clinical advisor perfecting a list of suggestions. Your specific task is to extract patient context, identify compliant points, and add "why" and "verbatimQuote" fields to each suggestion. Ensure the output is valid JSON with structure: { "patientContext": {}, "suggestions": [{ "suggestion": "...", "priority": "...", "why": "...", "verbatimQuote": "..." }], "alreadyCompliant": [] }`;
    const step2UserPrompt = `CLINICAL NOTE:\n${clinicalNote}\n\nGUIDELINE CONTENT:\n${guidelineContent}\n\nDRAFT SUGGESTIONS:\n${JSON.stringify(initialSuggestions, null, 2)}\n\nTASK: 1. Extract patient context. 2. Identify already compliant. 3. Add why/verbatimQuote. 4. Return JSON.`;
    const messagesStep2 = [{ role: 'system', content: step2SystemPrompt }, { role: 'user', content: step2UserPrompt }];
    const resultStep2 = await routeToAI({ messages: messagesStep2 }, userId, targetModel);

    if (!resultStep2 || !resultStep2.content) {
        return { patientContext: {}, suggestions: initialSuggestions.map(s => ({ ...s, suggestion: s.name, why: 'Reasoning generation failed', verbatimQuote: '' })), alreadyCompliant: [] };
    }

    try {
        return JSON.parse(resultStep2.content.trim().replace(/```json\n?|\n?```/g, ''));
    } catch (e) {
        return { patientContext: {}, suggestions: initialSuggestions.map(s => ({ ...s, suggestion: s.name, why: 'Reasoning generation failed', verbatimQuote: '' })), alreadyCompliant: [] };
    }
}

/**
 * Evaluates the quality of AI-generated suggestions against a guideline.
 *
 * Used for quality assurance and learning improvement. Calculates
 * precision (correctness) and recall (completeness) scores.
 *
 * @async
 * @param {string} clinicalNote - The clinical note text
 * @param {string} guidelineContent - Full guideline text
 * @param {string} guidelineTitle - Guideline title
 * @param {Array&lt;Object>} suggestions - Suggestions to evaluate
 * @param {Array&lt;string>} alreadyCompliant - Points identified as compliant
 * @param {string} userId - User ID for AI routing
 * @returns {Promise&lt;Object>} Evaluation results
 * @returns {number} returns.recallScore - Completeness score (0-1)
 * @returns {number} returns.precisionScore - Accuracy score (0-1)
 * @returns {Object} returns.counts - Count statistics
 * @returns {Array} returns.missedRecommendations - Recommendations AI missed
 * @returns {Array} returns.suggestionEvaluations - Per-suggestion verdicts
 * @returns {Array} returns.falseNegatives - Incorrectly marked as compliant
 */
async function evaluateSuggestions(clinicalNote, guidelineContent, guidelineTitle, suggestions, alreadyCompliant, userId) {
    const promptConfig = (global.prompts || require('../../prompts.json'))['evaluateSuggestions'];
    const systemPrompt = promptConfig?.system_prompt || `You are a clinical guideline expert evaluating AI-generated suggestions... Return ONLY valid JSON.`;
    const userPrompt = (promptConfig?.prompt || `CLINICAL NOTE:\n{{clinicalNote}}\n\nGUIDELINE TITLE: {{guidelineTitle}}\n\nFULL GUIDELINE CONTENT:\n{{guidelineContent}}\n\nAI-GENERATED SUGGESTIONS:\n{{suggestions}}\n\nAI-IDENTIFIED AS ALREADY COMPLIANT:\n{{alreadyCompliant}}\n\nEvaluate the AI's output...`)
        .replace('{{clinicalNote}}', clinicalNote).replace('{{guidelineTitle}}', guidelineTitle).replace('{{guidelineContent}}', guidelineContent)
        .replace('{{suggestions}}', JSON.stringify(suggestions)).replace('{{alreadyCompliant}}', JSON.stringify(alreadyCompliant));

    const result = await routeToAI({ messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }] }, userId);
    if (!result || !result.content) {
        return { recallScore: 0, precisionScore: 0, completenessScore: 0, accuracyScore: 0, counts: { suggestionsTotal: 0, correct: 0, incorrect: 0, redundant: 0, missed: 0, falseNegatives: 0 }, missedRecommendations: [], suggestionEvaluations: [], falseNegatives: [], error: 'No response from evaluator' };
    }
    try {
        const parsed = JSON.parse(result.content.trim().replace(/```json\n?|\n?```/g, ''));
        const counts = parsed.counts || { suggestionsTotal: parsed.suggestionEvaluations?.length || 0, correct: parsed.suggestionEvaluations?.filter(e => e.verdict === 'correct').length || 0, incorrect: parsed.suggestionEvaluations?.filter(e => e.verdict === 'incorrect').length || 0, redundant: parsed.suggestionEvaluations?.filter(e => e.verdict === 'redundant').length || 0, missed: parsed.missedRecommendations?.length || 0, falseNegatives: parsed.falseNegatives?.length || 0 };
        const suggestionsTotal = counts.suggestionsTotal || 1;
        const recallScore = parsed.recallScore ?? parsed.completenessScore ?? 0;
        const precisionScore = parsed.precisionScore ?? parsed.accuracyScore ?? 0;
        return { ...parsed, recallScore, precisionScore, counts, completenessScore: recallScore, accuracyScore: precisionScore };
    } catch (e) {
        return { recallScore: 0, precisionScore: 0, completenessScore: 0, accuracyScore: 0, counts: { suggestionsTotal: 0 }, error: 'Failed to parse evaluation' };
    }
}

/**
 * Generates suggested improvements to AI prompts based on evaluation results.
 *
 * Analyzes patterns in evaluation failures to recommend prompt modifications.
 *
 * @async
 * @param {string} currentPrompt - The current prompt being evaluated
 * @param {Array&lt;Object>} evaluationResults - Array of evaluation results
 * @param {number} avgRecall - Average recall score across evaluations
 * @param {number} avgPrecision - Average precision score across evaluations
 * @param {number} avgLatency - Average latency in milliseconds
 * @param {string} userId - User ID for AI routing
 * @param {Object} [additionalMetrics={}] - Extra metrics to consider
 * @returns {Promise&lt;Object>} Improvement suggestions
 * @returns {Object} returns.analysis - Pattern analysis
 * @returns {Array} returns.suggestedChanges - Recommended prompt changes
 */
async function generatePromptImprovements(currentPrompt, evaluationResults, avgRecall, avgPrecision, avgLatency, userId, additionalMetrics = {}) {
    const promptConfig = (global.prompts || require('../../prompts.json'))['generatePromptImprovements'];
    const systemPrompt = promptConfig?.system_prompt || `You are an expert at prompt engineering... Return ONLY valid JSON.`;
    const evaluationSummary = evaluationResults.map((evaluationItem, idx) => ({ scenario: idx + 1, recall: evaluationItem.recallScore, precision: evaluationItem.precisionScore, assessment: evaluationItem.overallAssessment }));
    const userPrompt = (promptConfig?.prompt || `CURRENT PROMPT BEING EVALUATED:\n{{currentPrompt}}\n\nEVALUATION RESULTS:\n{{evaluationResults}}\n\nMETRICS:\nRecall: {{avgRecall}}\nPrecision: {{avgPrecision}}\n\nAnalyze...`)
        .replace('{{currentPrompt}}', JSON.stringify(currentPrompt)).replace('{{evaluationResults}}', JSON.stringify(evaluationSummary))
        .replace('{{avgRecall}}', avgRecall).replace('{{avgPrecision}}', avgPrecision);

    const result = await routeToAI({ messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }] }, userId);
    if (!result || !result.content) return { analysis: { keyPatterns: [], rootCauses: [] }, suggestedChanges: [], error: 'No response' };
    try {
        return JSON.parse(result.content.trim().replace(/```json\n?|\n?```/g, ''));
    } catch (e) {
        return { analysis: { keyPatterns: [], rootCauses: [] }, suggestedChanges: [], error: 'Failed to parse' };
    }
}

/**
 * Extracts lessons learned from an evaluation for future improvement.
 *
 * Generates prose summaries of what went wrong and how to avoid
 * similar mistakes in future analyses.
 *
 * @async
 * @param {string} guidelineTitle - Title of the evaluated guideline
 * @param {Object} evaluation - Evaluation results
 * @param {Array&lt;Object>} suggestions - The suggestions that were evaluated
 * @param {string} userId - User ID for AI routing
 * @returns {Promise&lt;Object|null>} Lessons learned or null if no issues found
 * @returns {string} returns.learningText - Prose summary of lessons
 */
async function extractLessonsLearned(guidelineTitle, evaluation, suggestions, userId) {
    if ((evaluation.missedRecommendations?.length || 0) === 0 &amp;&amp; (evaluation.suggestionEvaluations?.filter(s => s.verdict === 'incorrect').length || 0) === 0) return null;
    const systemPrompt = `You are an expert at analysing AI performance... Write 1-3 short paragraphs...`;
    const userPrompt = `GUIDELINE: ${guidelineTitle}\n\nEVALUATION RESULTS:\n${JSON.stringify(evaluation, null, 2)}\n\nSUGGESTIONS:\n${JSON.stringify(suggestions, null, 2)}\n\nWrite a concise prose summary of key lessons learned.`;
    const result = await routeToAI({ messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }] }, userId);
    if (!result || !result.content) return null;
    return { learningText: result.content.trim() };
}

/**
 * Synthesizes existing and new learning into a coherent summary using AI.
 *
 * Prevents learning from growing unboundedly by merging new insights
 * with existing knowledge while preserving key lessons.
 *
 * @async
 * @param {string} existingLearning - Current accumulated learning text
 * @param {string} newLearning - New lessons to incorporate
 * @param {string} guidelineTitle - Guideline title for context
 * @param {string} userId - User ID for AI routing
 * @returns {Promise&lt;string>} Synthesized learning text
 */
async function foldLearningWithLLM(existingLearning, newLearning, guidelineTitle, userId) {
    const systemPrompt = `You are an expert at synthesising clinical guideline knowledge... Preserve existing, incorporate new. Concise.`;
    const userPrompt = `GUIDELINE: ${guidelineTitle}\n\nEXISTING:\n${existingLearning}\n\nNEW:\n${newLearning}\n\nSynthesise...`;
    const result = await routeToAI({ messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }] }, userId);
    return result?.content?.trim() || newLearning;
}

/**
 * Stores accumulated learning for a guideline in Firestore.
 *
 * If learning already exists, folds new lessons into existing
 * knowledge using AI synthesis.
 *
 * @async
 * @param {string} guidelineId - The guideline document ID
 * @param {Object} newLessons - New lessons to store
 * @param {string} newLessons.learningText - The learning text content
 * @param {string} guidelineTitle - Guideline title for synthesis context
 * @param {string} userId - User ID for AI routing
 * @returns {Promise&lt;void>}
 */
async function storeGuidelineLearning(guidelineId, newLessons, guidelineTitle, userId) {
    if (!newLessons || !newLessons.learningText) return;
    try {
        const learningRef = db.collection('guidelines').doc(guidelineId).collection('metadata').doc('interpretationHints');
        const learningDoc = await learningRef.get();
        let finalLearningText = newLessons.learningText;
        let newVersion = 1;
        if (learningDoc.exists) {
            const existingData = learningDoc.data();
            newVersion = (existingData?.version || 0) + 1;
            if (existingData.learningText) finalLearningText = await foldLearningWithLLM(existingData.learningText, newLessons.learningText, guidelineTitle, userId);
        }
        await learningRef.set({ learningText: finalLearningText, lastUpdated: admin.firestore.FieldValue.serverTimestamp(), version: newVersion });
    } catch (error) { console.error('[EVOLVE-LEARNING] Error storing learning:', error); }
}

/**
 * Refines suggestions based on evaluation feedback.
 *
 * Uses evaluation results to improve a previous set of suggestions,
 * addressing missed recommendations and correcting errors.
 *
 * @async
 * @param {Array&lt;Object>} previousSuggestions - Original suggestions
 * @param {Object} previousEvaluation - Evaluation of original suggestions
 * @param {string} clinicalNote - The clinical note text
 * @param {string} guidelineContent - Full guideline text
 * @param {string} guidelineTitle - Guideline title
 * @param {string} userId - User ID for AI routing
 * @param {string|null} targetProvider - Specific provider to use
 * @param {string|null} [guidelineId=null] - Guideline ID for loading hints
 * @returns {Promise&lt;Object>} Refined analysis results (same structure as analyzeGuidelineForPatient)
 */
async function refineSuggestions(previousSuggestions, previousEvaluation, clinicalNote, guidelineContent, guidelineTitle, userId, targetProvider, guidelineId = null) {
    let hintsText = '';
    if (guidelineId) {
        const learning = await loadGuidelineLearning(guidelineId);
        if (learning) hintsText = formatLearningForPrompt(learning);
    }
    const systemPrompt = `You are a clinical advisor reviewing and improving another AI's suggestions... Return ONLY valid JSON.`;
    const userPrompt = `CLINICAL NOTE:\n${clinicalNote}\n\nGUIDELINE:\n${guidelineContent}\n\nPREVIOUS SUGGESTIONS:\n${JSON.stringify(previousSuggestions)}\n\nEVALUATION:\n${JSON.stringify(previousEvaluation)}\n${hintsText}\n\nProvide IMPROVED suggestions.`;
    const result = await routeToAI({ messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }] }, userId, targetProvider);
    if (!result || !result.content) return { patientContext: {}, suggestions: previousSuggestions, alreadyCompliant: [], refinementNotes: 'No response' };
    try {
        return JSON.parse(result.content.trim().replace(/```json\n?|\n?```/g, ''));
    } catch (e) {
        return { patientContext: {}, suggestions: previousSuggestions, alreadyCompliant: [], refinementNotes: 'Failed to parse' };
    }
}

/**
 * Extract gestational age in weeks from clinical note or patient context
 * @param {string} clinicalNote - The clinical note text
 * @param {Object} patientContext - Patient context object
 * @returns {number|null} - Gestational age in weeks, or null if not found
 */
function extractGestationalAge(clinicalNote, patientContext) {
    // Check patient context first
    if (patientContext?.gestationalAge) {
        const match = String(patientContext.gestationalAge).match(/(\d+)\s*\+?\s*\d*/);
        if (match) return parseInt(match[1]);
    }

    // Look for patterns like "32+4", "32 weeks", "36+0 weeks"
    const patterns = [
        /(\d{1,2})\s*\+\s*\d+\s*weeks/i,
        /(\d{1,2})\s*\+\s*\d+/,
        /(\d{1,2})\s*weeks\s*\+\s*\d+/i,
        /at\s*(\d{1,2})\s*weeks/i,
        /G\d+P\d+.*?(\d{1,2})\+\d+/i
    ];

    for (const pattern of patterns) {
        const match = clinicalNote.match(pattern);
        if (match) {
            const weeks = parseInt(match[1]);
            if (weeks >= 4 &amp;&amp; weeks &lt;= 44) return weeks; // Sanity check
        }
    }

    return null;
}

/**
 * Extract patient blood type/Rh status from clinical note
 * @param {string} clinicalNote - The clinical note text
 * @returns {Object} - { rhesus: 'positive'|'negative'|null }
 */
function extractBloodType(clinicalNote) {
    const rhPositivePatterns = [
        /Rh\+ve/i,
        /Rh\s*positive/i,
        /RhD\s*positive/i,
        /Rhesus\s*positive/i
    ];

    const rhNegativePatterns = [
        /Rh\-ve/i,
        /Rh\s*negative/i,
        /RhD\s*negative/i,
        /Rhesus\s*negative/i
    ];

    for (const pattern of rhPositivePatterns) {
        if (pattern.test(clinicalNote)) return { rhesus: 'positive' };
    }

    for (const pattern of rhNegativePatterns) {
        if (pattern.test(clinicalNote)) return { rhesus: 'negative' };
    }

    return { rhesus: null };
}

/**
 * Rule-based filters for common nonsensical patterns
 * @param {Array} suggestions - Array of suggestion objects
 * @param {string} clinicalNote - The clinical note text
 * @param {Object} patientContext - Patient context
 * @returns {Object} - { validSuggestions, filteredOut }
 */
function applyRuleBasedFilters(suggestions, clinicalNote, patientContext) {
    const currentGA = extractGestationalAge(clinicalNote, patientContext);
    const bloodType = extractBloodType(clinicalNote);
    const filteredOut = [];
    const validSuggestions = [];

    console.log(`[SENSE-CHECK-RULES] Current GA: ${currentGA} weeks, Rhesus: ${bloodType.rhesus}`);

    for (const suggestion of suggestions) {
        const suggestionText = (suggestion.suggestion || suggestion.text || '').toLowerCase();
        let filterReason = null;

        // Rule 1: Check for temporal impossibilities (suggesting past interventions)
        if (currentGA) {
            // Look for "at X weeks" or "X-Y weeks" patterns in suggestion
            const weekPatterns = [
                /at\s*(\d{1,2})\s*weeks/i,
                /(\d{1,2})\s*-\s*(\d{1,2})\s*weeks/i,
                /around\s*(\d{1,2})\s*weeks/i
            ];

            for (const pattern of weekPatterns) {
                const match = suggestionText.match(pattern);
                if (match) {
                    const suggestedWeek = parseInt(match[1]);
                    // Check if suggested intervention is in the past
                    if (suggestedWeek &lt; currentGA - 1) { // Allow 1 week grace for rounding
                        filterReason = `Patient is at ${currentGA} weeks - cannot schedule intervention at ${suggestedWeek} weeks (already past)`;
                        break;
                    }
                }
            }
        }

        // Rule 2: Check for Rhesus incompatibility
        if (bloodType.rhesus === 'positive') {
            // If patient is Rh positive, anti-D suggestions don't apply
            if (/anti-d/i.test(suggestionText) &amp;&amp; /rhd\s*negative/i.test(suggestionText)) {
                filterReason = `Patient is Rhesus positive - anti-D prophylaxis only applies to Rh negative patients`;
            }
        }

        // Rule 3: Check if action already documented as completed
        const completedPatterns = [
            { pattern: /booking.*blood/i, completed: /booking.*blood.*done|booking.*blood.*completed|booking.*blood.*taken/i },
            { pattern: /dating.*scan/i, completed: /dating.*scan.*done|dating.*scan.*completed|dating.*scan.*confirmed/i },
            { pattern: /anomaly.*scan/i, completed: /anomaly.*scan.*done|anomaly.*scan.*completed|anomaly.*scan.*normal/i }
        ];

        for (const { pattern, completed } of completedPatterns) {
            if (pattern.test(suggestionText) &amp;&amp; completed.test(clinicalNote)) {
                filterReason = `Action already documented as completed in clinical note`;
                break;
            }
        }

        if (filterReason) {
            filteredOut.push({ ...suggestion, filterReason });
        } else {
            validSuggestions.push(suggestion);
        }
    }

    return { validSuggestions, filteredOut };
}

/**
 * Sense-check suggestions against clinical context to filter out impossible/nonsensical recommendations
 * @param {Array} suggestions - Array of suggestion objects
 * @param {string} clinicalNote - The clinical note text
 * @param {Object} patientContext - Patient context extracted by AI (gestational age, etc.)
 * @param {string} userId - User ID for AI routing
 * @returns {Promise&lt;Object>} - { validSuggestions, filteredOut }
 */
async function senseCheckSuggestions(suggestions, clinicalNote, patientContext, userId) {
    if (!suggestions || suggestions.length === 0) {
        return { validSuggestions: [], filteredOut: [] };
    }

    console.log('[SENSE-CHECK] Checking', suggestions.length, 'suggestions for temporal/logical consistency');

    // First apply rule-based filters (fast, deterministic)
    const ruleBasedResult = applyRuleBasedFilters(suggestions, clinicalNote, patientContext);

    if (ruleBasedResult.filteredOut.length > 0) {
        console.log(`[SENSE-CHECK-RULES] Filtered out ${ruleBasedResult.filteredOut.length} suggestions:`,
            ruleBasedResult.filteredOut.map(f => `"${f.suggestion?.substring(0, 60)}..." (${f.filterReason})`));
    }

    // If all suggestions were filtered by rules, return early
    if (ruleBasedResult.validSuggestions.length === 0) {
        return ruleBasedResult;
    }

    // Then apply AI-based validation for more nuanced cases
    const currentGA = extractGestationalAge(clinicalNote, patientContext);
    const bloodType = extractBloodType(clinicalNote);

    const systemPrompt = `You are a clinical reasoning validator. Your job is to identify suggestions that are IMPOSSIBLE or NONSENSICAL given the patient's current state.

CRITICAL CHECKS:
1. TEMPORAL IMPOSSIBILITIES: If a suggestion recommends an intervention at a specific gestational age (e.g., "at 28 weeks") and the patient is ALREADY PAST that point, it MUST be filtered out.
2. BLOOD TYPE MISMATCHES: If suggestion is for "RhD negative" patients but patient is Rh positive (or vice versa), it MUST be filtered out.
3. COMPLETED ACTIONS: If the clinical note documents an action as already done/completed, suggesting it again is nonsensical.

Be STRICT about temporal issues - suggesting past interventions is clearly wrong.

Return ONLY valid JSON with this structure:
{
  "validSuggestions": [&lt;array of suggestion IDs that make sense>],
  "filteredOut": [
    {
      "id": &lt;suggestion ID>,
      "reason": "&lt;brief explanation why it's nonsensical>"
    }
  ]
}`;

    const contextInfo = `Current gestational age: ${currentGA || 'unknown'} weeks
Patient Rhesus status: ${bloodType.rhesus || 'unknown'}`;

    const userPrompt = `${contextInfo}

PATIENT CONTEXT:
${JSON.stringify(patientContext, null, 2)}

CLINICAL NOTE:
${clinicalNote}

SUGGESTIONS TO VALIDATE:
${ruleBasedResult.validSuggestions.map((s, idx) => `[ID: ${idx}] ${s.suggestion || s.name || s.text || ''}`).join('\n')}

TASK: Identify which suggestions are impossible/nonsensical given the current patient state. Pay special attention to temporal issues and blood type compatibility.`;

    try {
        const result = await routeToAI({
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: userPrompt }
            ]
        }, userId);

        if (!result || !result.content) {
            console.warn('[SENSE-CHECK-AI] No response from AI, using only rule-based filtering');
            return ruleBasedResult;
        }

        const parsed = JSON.parse(result.content.trim().replace(/```json\n?|\n?```/g, ''));
        const validIds = new Set(parsed.validSuggestions || []);
        const filteredOutMap = new Map((parsed.filteredOut || []).map(f => [f.id, f.reason]));

        const validSuggestions = ruleBasedResult.validSuggestions.filter((_, idx) => validIds.has(idx));
        const aiFilteredOut = ruleBasedResult.validSuggestions
            .map((s, idx) => ({ ...s, originalIndex: idx, filterReason: filteredOutMap.get(idx) }))
            .filter(s => s.filterReason);

        const allFilteredOut = [...ruleBasedResult.filteredOut, ...aiFilteredOut];

        console.log(`[SENSE-CHECK] Final result: ${validSuggestions.length} valid, ${allFilteredOut.length} filtered out (${ruleBasedResult.filteredOut.length} by rules, ${aiFilteredOut.length} by AI)`);
        if (aiFilteredOut.length > 0) {
            console.log('[SENSE-CHECK-AI] AI filtered:', aiFilteredOut.map(f => `"${f.suggestion?.substring(0, 60)}..." (${f.filterReason})`));
        }

        return { validSuggestions, filteredOut: allFilteredOut };
    } catch (error) {
        console.error('[SENSE-CHECK-AI] Error during AI validation:', error);
        // On error, return rule-based results rather than blocking
        return ruleBasedResult;
    }
}

/**
 * Sense-check retrieved guidelines to filter out irrelevant ones
 * @param {Object} categories - Categorized guidelines { mostRelevant: [], potentiallyRelevant: [], ... }
 * @param {string} clinicalNote - The clinical note text
 * @param {string} userId - User ID for AI routing
 * @returns {Promise&lt;Object>} - { validCategories, filteredOut }
 */
async function senseCheckGuidelines(categories, clinicalNote, userId) {
    if (!categories || (!categories.mostRelevant?.length &amp;&amp; !categories.potentiallyRelevant?.length)) {
        return { validCategories: categories, filteredOut: [] };
    }

    console.log('[SENSE-CHECK-GUIDELINES] Checking guidelines for relevance to patient');

    // Combine mostRelevant and potentiallyRelevant for checking
    const guidelinesToCheck = [
        ...(categories.mostRelevant || []).map(g => ({ ...g, category: 'mostRelevant' })),
        ...(categories.potentiallyRelevant || []).map(g => ({ ...g, category: 'potentiallyRelevant' }))
    ];

    if (guidelinesToCheck.length === 0) {
        return { validCategories: categories, filteredOut: [] };
    }

    const systemPrompt = `You are a clinical reasoning validator. Your job is to identify guidelines that are COMPLETELY IRRELEVANT to the patient's condition.

CRITICAL: Only filter out guidelines when there is a CLEAR MISMATCH between:
1. A specific disease/condition mentioned in the guideline title
2. The patient NOT having that disease/condition

Common patterns to detect:
- Guidelines about specific diseases (e.g., "Sickle Cell Disease", "Thalassemia", "HIV") when patient doesn't have that disease
- Guidelines about specific procedures (e.g., "IVF", "Caesarean Section") when patient hasn't had that procedure
- Guidelines about specific contexts (e.g., "Multiple Pregnancy") when patient isn't in that context

DO NOT filter out:
- General guidelines that could apply broadly (e.g., "Antenatal Care", "Labour Management")
- Guidelines about screening/testing (these are often preventive)
- Guidelines that mention complications or risks the patient COULD develop

Return ONLY valid JSON with this structure:
{
  "validGuidelines": [&lt;array of guideline IDs that ARE relevant or COULD BE relevant>],
  "filteredOut": [
    {
      "id": "&lt;guideline ID>",
      "title": "&lt;guideline title>",
      "reason": "&lt;brief explanation why it's completely irrelevant>"
    }
  ]
}`;

    const userPrompt = `CLINICAL NOTE:
${clinicalNote}

GUIDELINES TO VALIDATE:
${guidelinesToCheck.map((g, idx) => `[ID: ${idx}] ${g.title || g.name || ''}`).join('\n')}

TASK: Identify which guidelines are COMPLETELY IRRELEVANT to this patient. Only filter out guidelines when there's a clear mismatch (e.g., sickle cell guideline for patient without sickle cell). Be conservative - when in doubt, keep the guideline.`;

    try {
        const result = await routeToAI({
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: userPrompt }
            ]
        }, userId);

        if (!result || !result.content) {
            console.warn('[SENSE-CHECK-GUIDELINES] No response from AI, passing all guidelines through');
            return { validCategories: categories, filteredOut: [] };
        }

        const parsed = JSON.parse(result.content.trim().replace(/```json\n?|\n?```/g, ''));
        const validIds = new Set(parsed.validGuidelines || []);
        const filteredOutMap = new Map((parsed.filteredOut || []).map(f => [f.id, f]));

        // Rebuild categories with only valid guidelines
        const validMostRelevant = [];
        const validPotentiallyRelevant = [];
        const filteredOut = [];

        guidelinesToCheck.forEach((guideline, idx) => {
            if (validIds.has(idx)) {
                // Keep guideline in its original category
                if (guideline.category === 'mostRelevant') {
                    validMostRelevant.push(guideline);
                } else {
                    validPotentiallyRelevant.push(guideline);
                }
            } else if (filteredOutMap.has(idx)) {
                // Guideline was filtered out
                const filterInfo = filteredOutMap.get(idx);
                filteredOut.push({
                    ...guideline,
                    filterReason: filterInfo.reason
                });
            } else {
                // Default: keep it if not explicitly filtered
                if (guideline.category === 'mostRelevant') {
                    validMostRelevant.push(guideline);
                } else {
                    validPotentiallyRelevant.push(guideline);
                }
            }
        });

        const validCategories = {
            mostRelevant: validMostRelevant,
            potentiallyRelevant: validPotentiallyRelevant,
            lessRelevant: categories.lessRelevant || [],
            notRelevant: categories.notRelevant || []
        };

        console.log(`[SENSE-CHECK-GUIDELINES] Result: ${validMostRelevant.length + validPotentiallyRelevant.length} valid, ${filteredOut.length} filtered out`);
        if (filteredOut.length > 0) {
            console.log('[SENSE-CHECK-GUIDELINES] Filtered out:', filteredOut.map(f => `"${f.title}" (${f.filterReason})`).join('; '));
        }

        return { validCategories, filteredOut };
    } catch (error) {
        console.error('[SENSE-CHECK-GUIDELINES] Error during validation:', error);
        // On error, pass all guidelines through rather than blocking
        return { validCategories: categories, filteredOut: [] };
    }
}

module.exports = {
    createPromptForChunk,
    mergeChunkResults,
    parseChunkResponse,
    routeToAI,
    sendToAI,
    analyzeGuidelineForPatient,
    checkComplianceAndSuggest,
    filterRelevantPracticePoints,
    filterImportantPracticePoints,
    loadGuidelineLearning,
    storeGuidelineLearning,
    evaluateSuggestions,
    generatePromptImprovements,
    extractLessonsLearned,
    refineSuggestions,
    senseCheckSuggestions,
    senseCheckGuidelines,
    SEQUENTIAL_LLM_CHAIN
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-server_services_ai.html">server/services/ai</a></li><li><a href="module-server_services_pdf.html">server/services/pdf</a></li></ul><h3>Classes</h3><ul><li><a href="ClinicalDataAnonymiser.html">ClinicalDataAnonymiser</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Logger">Logger</a></li><li><a href="global.html#admin">admin</a></li><li><a href="global.html#analyzeNoteAgainstGuideline">analyzeNoteAgainstGuideline</a></li><li><a href="global.html#applyColoredReplacements">applyColoredReplacements</a></li><li><a href="global.html#applyMobileLayout">applyMobileLayout</a></li><li><a href="global.html#arbitrateCGPDisagreements">arbitrateCGPDisagreements</a></li><li><a href="global.html#assessClinicalImpact">assessClinicalImpact</a></li><li><a href="global.html#assessGuidanceFailureRisk">assessGuidanceFailureRisk</a></li><li><a href="global.html#assessRisks">assessRisks</a></li><li><a href="global.html#autoInitializeMobile">autoInitializeMobile</a></li><li><a href="global.html#autoInitializeVersion">autoInitializeVersion</a></li><li><a href="global.html#automatedGuidanceAssessment">automatedGuidanceAssessment</a></li><li><a href="global.html#batchAutomatedAssessment">batchAutomatedAssessment</a></li><li><a href="global.html#batchEvaluateGuidance">batchEvaluateGuidance</a></li><li><a href="global.html#calculateNextReviewDate">calculateNextReviewDate</a></li><li><a href="global.html#calculateOverallScore">calculateOverallScore</a></li><li><a href="global.html#calculatePassRate">calculatePassRate</a></li><li><a href="global.html#calculateRiskLevel">calculateRiskLevel</a></li><li><a href="global.html#calculateTestCoverage">calculateTestCoverage</a></li><li><a href="global.html#calculateTestCoveragePercentage">calculateTestCoveragePercentage</a></li><li><a href="global.html#categoriseByScore">categoriseByScore</a></li><li><a href="global.html#checkDisclaimerAcceptance">checkDisclaimerAcceptance</a></li><li><a href="global.html#chunkText">chunkText</a></li><li><a href="global.html#clearHighlightInEditor">clearHighlightInEditor</a></li><li><a href="global.html#clearJobQueue">clearJobQueue</a></li><li><a href="global.html#closeMobileSettingsOverlay">closeMobileSettingsOverlay</a></li><li><a href="global.html#countFailedTests">countFailedTests</a></li><li><a href="global.html#countPassedTests">countPassedTests</a></li><li><a href="global.html#createVariationPrompt">createVariationPrompt</a></li><li><a href="global.html#crossValidateClinicalGuidancePoints">crossValidateClinicalGuidancePoints</a></li><li><a href="global.html#deleteDocuments">deleteDocuments</a></li><li><a href="global.html#deleteGuidelineChunks">deleteGuidelineChunks</a></li><li><a href="global.html#detectMobile">detectMobile</a></li><li><a href="global.html#determineFailureProbability">determineFailureProbability</a></li><li><a href="global.html#determineFailureSeverity">determineFailureSeverity</a></li><li><a href="global.html#determinePriority">determinePriority</a></li><li><a href="global.html#determineSeverity">determineSeverity</a></li><li><a href="global.html#determineTestStatus">determineTestStatus</a></li><li><a href="global.html#ensureAnonymisedForOutbound">ensureAnonymisedForOutbound</a></li><li><a href="global.html#evaluateAccuracy">evaluateAccuracy</a></li><li><a href="global.html#evaluateCompleteness">evaluateCompleteness</a></li><li><a href="global.html#evaluateContextualAppropriateness">evaluateContextualAppropriateness</a></li><li><a href="global.html#evaluateGuidance">evaluateGuidance</a></li><li><a href="global.html#evaluatePrecision">evaluatePrecision</a></li><li><a href="global.html#extractClinicalGuidancePoints">extractClinicalGuidancePoints</a></li><li><a href="global.html#extractElementCount">extractElementCount</a></li><li><a href="global.html#extractIssues">extractIssues</a></li><li><a href="global.html#extractMetadata">extractMetadata</a></li><li><a href="global.html#extractOrganisationFromTitle">extractOrganisationFromTitle</a></li><li><a href="global.html#extractRelevanceScore">extractRelevanceScore</a></li><li><a href="global.html#fetchContent">fetchContent</a></li><li><a href="global.html#formatExecutionRecords">formatExecutionRecords</a></li><li><a href="global.html#formatRelevanceScore">formatRelevanceScore</a></li><li><a href="global.html#formatTestResults">formatTestResults</a></li><li><a href="global.html#fs">fs</a></li><li><a href="global.html#generateAuditScenarios">generateAuditScenarios</a></li><li><a href="global.html#generateBaseScenario">generateBaseScenario</a></li><li><a href="global.html#generateChunkId">generateChunkId</a></li><li><a href="global.html#generateDetailedFindings">generateDetailedFindings</a></li><li><a href="global.html#generateEdgeCaseVariations">generateEdgeCaseVariations</a></li><li><a href="global.html#generateElementCoverage">generateElementCoverage</a></li><li><a href="global.html#generateISOCompliantReport">generateISOCompliantReport</a></li><li><a href="global.html#generateMitigationStrategies">generateMitigationStrategies</a></li><li><a href="global.html#generateRecommendations">generateRecommendations</a></li><li><a href="global.html#generateReportId">generateReportId</a></li><li><a href="global.html#generateScenarioVariations">generateScenarioVariations</a></li><li><a href="global.html#generateScenariosForElements">generateScenariosForElements</a></li><li><a href="global.html#generateSimpleDisplayName">generateSimpleDisplayName</a></li><li><a href="global.html#generateTraceabilityMatrix">generateTraceabilityMatrix</a></li><li><a href="global.html#generateTraceabilityReport">generateTraceabilityReport</a></li><li><a href="global.html#generateTrustAcronym">generateTrustAcronym</a></li><li><a href="global.html#generateVariationTranscript">generateVariationTranscript</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAllPrompts">getAllPrompts</a></li><li><a href="global.html#getAuditInteractions">getAuditInteractions</a></li><li><a href="global.html#getAuditInteractionsForTest">getAuditInteractionsForTest</a></li><li><a href="global.html#getAuditResultsForTest">getAuditResultsForTest</a></li><li><a href="global.html#getAuditStatistics">getAuditStatistics</a></li><li><a href="global.html#getAuditTest">getAuditTest</a></li><li><a href="global.html#getAuditTests">getAuditTests</a></li><li><a href="global.html#getElementMapping">getElementMapping</a></li><li><a href="global.html#getGuidanceForThreshold">getGuidanceForThreshold</a></li><li><a href="global.html#getIdToken">getIdToken</a></li><li><a href="global.html#getIndexStats">getIndexStats</a></li><li><a href="global.html#getIngestionStatus">getIngestionStatus</a></li><li><a href="global.html#getInteractionStatistics">getInteractionStatistics</a></li><li><a href="global.html#getMaximumValue">getMaximumValue</a></li><li><a href="global.html#getMinimumValue">getMinimumValue</a></li><li><a href="global.html#getNextLLMProvider">getNextLLMProvider</a></li><li><a href="global.html#getPromptText">getPromptText</a></li><li><a href="global.html#getRelevanceCategory">getRelevanceCategory</a></li><li><a href="global.html#getShortHospitalTrust">getShortHospitalTrust</a></li><li><a href="global.html#getTraceabilityChain">getTraceabilityChain</a></li><li><a href="global.html#getTraceabilityMatrix">getTraceabilityMatrix</a></li><li><a href="global.html#getValueAboveThreshold">getValueAboveThreshold</a></li><li><a href="global.html#getValueBelowThreshold">getValueBelowThreshold</a></li><li><a href="global.html#hideSelectionButtons">hideSelectionButtons</a></li><li><a href="global.html#highlightTextInEditor">highlightTextInEditor</a></li><li><a href="global.html#ingestFromFirestore">ingestFromFirestore</a></li><li><a href="global.html#initializeConnectivityMonitoring">initializeConnectivityMonitoring</a></li><li><a href="global.html#initializeMarked">initializeMarked</a></li><li><a href="global.html#initializeMobileDetection">initializeMobileDetection</a></li><li><a href="global.html#initializeMobileSettingsOverlay">initializeMobileSettingsOverlay</a></li><li><a href="global.html#initializePinecone">initializePinecone</a></li><li><a href="global.html#initializeSuggestionWizard">initializeSuggestionWizard</a></li><li><a href="global.html#injectParameterModification">injectParameterModification</a></li><li><a href="global.html#isOnline">isOnline</a></li><li><a href="global.html#isVectorDBAvailable">isVectorDBAvailable</a></li><li><a href="global.html#linkAuditResult">linkAuditResult</a></li><li><a href="global.html#loadHospitalTrustMappings">loadHospitalTrustMappings</a></li><li><a href="global.html#loadVersionNumber">loadVersionNumber</a></li><li><a href="global.html#logAIInteraction">logAIInteraction</a></li><li><a href="global.html#logAuditInteraction">logAuditInteraction</a></li><li><a href="global.html#logStatusChange">logStatusChange</a></li><li><a href="global.html#mapElementsToGuideline">mapElementsToGuideline</a></li><li><a href="global.html#modifyScenarioParameter">modifyScenarioParameter</a></li><li><a href="global.html#openMobileSettingsOverlay">openMobileSettingsOverlay</a></li><li><a href="global.html#parseCitationsToLinks">parseCitationsToLinks</a></li><li><a href="global.html#parseJSONSafely">parseJSONSafely</a></li><li><a href="global.html#parseThresholdValue">parseThresholdValue</a></li><li><a href="global.html#postAuthenticated">postAuthenticated</a></li><li><a href="global.html#processAllGuidelines">processAllGuidelines</a></li><li><a href="global.html#processBatchGeneration">processBatchGeneration</a></li><li><a href="global.html#processFirestoreGuideline">processFirestoreGuideline</a></li><li><a href="global.html#processGuidelineFile">processGuidelineFile</a></li><li><a href="global.html#processJob">processJob</a></li><li><a href="global.html#processJobQueue">processJobQueue</a></li><li><a href="global.html#queryDocuments">queryDocuments</a></li><li><a href="global.html#queueJob">queueJob</a></li><li><a href="global.html#registerJobHandler">registerJobHandler</a></li><li><a href="global.html#reingestGuideline">reingestGuideline</a></li><li><a href="global.html#removeScenarioParameter">removeScenarioParameter</a></li><li><a href="global.html#repairGuidelineContent">repairGuidelineContent</a></li><li><a href="global.html#repairJSON">repairJSON</a></li><li><a href="global.html#scrollTextIntoView">scrollTextIntoView</a></li><li><a href="global.html#setButtonLoading">setButtonLoading</a></li><li><a href="global.html#showMainContent">showMainContent</a></li><li><a href="global.html#showPIIReviewInterface">showPIIReviewInterface</a></li><li><a href="global.html#showSelectionButtons">showSelectionButtons</a></li><li><a href="global.html#storeAuditInteraction">storeAuditInteraction</a></li><li><a href="global.html#storeAuditResult">storeAuditResult</a></li><li><a href="global.html#storeAuditTest">storeAuditTest</a></li><li><a href="global.html#storeAuditTrace">storeAuditTrace</a></li><li><a href="global.html#storeElementMapping">storeElementMapping</a></li><li><a href="global.html#storeTraceabilityMatrix">storeTraceabilityMatrix</a></li><li><a href="global.html#switchMobileView">switchMobileView</a></li><li><a href="global.html#syncGuidelinesInBatches">syncGuidelinesInBatches</a></li><li><a href="global.html#trackRiskResolution">trackRiskResolution</a></li><li><a href="global.html#updateAnalyseAndResetButtons">updateAnalyseAndResetButtons</a></li><li><a href="global.html#updateAuditTestStatus">updateAuditTestStatus</a></li><li><a href="global.html#updateClearFormattingButton">updateClearFormattingButton</a></li><li><a href="global.html#updatePromptsCache">updatePromptsCache</a></li><li><a href="global.html#updateUser">updateUser</a></li><li><a href="global.html#upsertDocuments">upsertDocuments</a></li><li><a href="global.html#validateScenario">validateScenario</a></li><li><a href="global.html#validateTraceability">validateTraceability</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
