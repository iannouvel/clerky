# Cursor Rules for Clerky

## Commit Rules

### 1. NEVER Skip Git Hooks
- NEVER use `--no-verify` or `--no-gpg-sign` flags when committing
- NEVER skip commit hooks unless explicitly requested by the user

### 2. NEVER Commit Without User Permission
- NEVER commit changes unless the user explicitly asks you to
- It is CRITICAL to only commit when explicitly asked
- The user will feel you are being too proactive if you commit without permission

### 3. ALWAYS Increment Version Before Committing
- ALWAYS increment the version in `package.json` before committing changes
- Use the appropriate version increment based on the type of change (patch/minor/major)
- The only exception is if the commit is ONLY updating documentation or non-code files that don't affect functionality
- If unsure which version increment to use, ask the user

### 4. Dist Folder Inclusion
- The `dist/` folder MUST be included in commits
- This folder contains built/compiled assets that are deployed
- ALWAYS run `npm run build` before committing to ensure the `dist/` folder is up to date
- The ONLY exception is if the commit contains ONLY documentation or non-code files (e.g., README.md, .cursorrules)
- Before committing, verify the build completes successfully and changes in source files are reflected in the `dist/` folder

### 5. Force Push Protection
- NEVER run `git push --force` to `main` or `master` branches
- Warn the user if they request a force push to main/master branches

### 6. Git Config Protection
- NEVER update the git config unless explicitly requested

## Version Incrementing Rules

### 1. Version Location
- Version is stored in `package.json` (currently at version 7.5.8)
- The version follows semantic versioning: MAJOR.MINOR.PATCH

### 2. Version Increment Commands
Use npm's built-in version management commands OR manually update package.json:

- **Patch version** (bug fixes, small changes): `7.5.8 → 7.5.9`
  ```bash
  npm version patch
  ```
  OR manually edit `package.json` and change the version string

- **Minor version** (new features, backwards compatible): `7.5.8 → 7.6.0`
  ```bash
  npm version minor
  ```

- **Major version** (breaking changes): `7.5.8 → 8.0.0`
  ```bash
  npm version major
  ```

### 3. When to Increment Which Version

- **PATCH**: Bug fixes, documentation updates, minor improvements, security patches
- **MINOR**: New features, new endpoints, significant improvements (backwards compatible)
- **MAJOR**: Breaking changes, major refactors, API changes that break compatibility

### 4. Version Increment Workflow

When the user asks to increment the version:

1. Ask which type of version increment is appropriate (patch/minor/major) if not specified
2. **IMPORTANT**: If using `npm version` command, it will auto-commit. Use manual increment instead for better control (see Increment-Commit-Push Workflow below)
3. The command will automatically:
   - Update `package.json`
   - Create a git commit with the version change
   - Create a git tag (unless `--no-git-tag-version` is used)
4. Inform the user that the version display on `index.html` will automatically update on next page load

### 5. Version Increment Without Git Tag

If the user prefers not to create git tags:
```bash
npm version patch --no-git-tag-version
```

Then manually commit the changes afterwards.

## Increment, Commit, and Push Workflow

### CRITICAL: PowerShell Syntax
- **NEVER use `&&` operator** - PowerShell doesn't support it
- Run commands separately, one at a time
- Check each command completes successfully before proceeding

### Standard Increment-Commit-Push Process

When the user says "incr commit push" or "increment, commit and push":

1. **Check current status:**
   ```powershell
   git status
   ```

2. **Increment version manually** (better control than `npm version`):
   - Read `package.json` to see current version
   - Determine increment type (patch/minor/major) - default to patch if not specified
   - Edit `package.json` using `search_replace` to update version number
   - Also update `package-lock.json` if it exists (it should auto-update on next npm install)

3. **Stage source files:**
   ```powershell
   git add [modified-source-files] package.json package-lock.json
   ```
   - Include all modified source files (e.g., `modules/audit.js`, `server.js`, `audit.html`)
   - Include `package.json` and `package-lock.json`

4. **Commit source files:**
   ```powershell
   git commit -m "Descriptive commit message about the changes"
   ```

5. **Run build:**
   ```powershell
   npm run build
   ```
   - Wait for build to complete successfully
   - Verify no errors in build output

6. **Stage dist folder:**
   ```powershell
   git add dist/
   ```

7. **Commit dist folder:**
   ```powershell
   git commit -m "Build: Update dist folder with version X.Y.Z"
   ```
   - Replace X.Y.Z with the actual version number

8. **Push to remote:**
   ```powershell
   git push
   ```

### Alternative: Single Commit Approach

If preferred, you can build first, then commit everything together:

1. Increment version in `package.json`
2. Run `npm run build`
3. Stage all files: `git add [source-files] package.json package-lock.json dist/`
4. Single commit: `git commit -m "Description with version X.Y.Z"`
5. Push: `git push`

### Error Prevention Tips

- **Always check `git status`** before starting to see what needs to be committed
- **Always run build before final commit** to ensure dist folder is current
- **Use separate commands** - don't chain with `&&` in PowerShell
- **Verify version number** is correct in `package.json` before committing
- **Check build output** for any errors or warnings before proceeding

## Build Process Rules

### 1. Before Committing
- If source files have changed, run `npm run build` to update the `dist/` folder
- Verify the build completes successfully before committing
- **ALWAYS** commit the `dist/` folder after building

### 2. Build Commands
- Standard build: `npm run build`
- Bundle Libretto: `npm run bundle-libretto`

## Deployment Monitoring Rules

### 1. Checking Render Deployment Logs via MCP

When deployment issues occur or the user asks to check deployment status:

1. **List Services** first to get the service ID:
   ```
   mcp_render_list_services
   ```
   - Look for the service named "clerky" 
   - Note its `id` (e.g., `srv-ct27s4a3esus73d590b0`)

2. **Check Recent Deploys** to see deployment status:
   ```
   mcp_render_list_deploys with serviceId and limit: 5
   ```
   - Check the `status` field: `live`, `update_failed`, `build_failed`, etc.
   - Note the deploy `id` if you need detailed logs

3. **View Application Logs** to see runtime errors:
   ```
   mcp_render_list_logs with:
   - resource: [serviceId]
   - limit: 100
   - type: ["app"]
   - direction: "backward"
   - startTime: (recent timestamp, e.g., last hour)
   ```
   - Look for `level: "critical"` or `level: "error"` messages
   - Check for SyntaxError, ReferenceError, or other runtime errors
   - Look for stack traces to identify exact line numbers

4. **View Build Logs** if deployment failed during build:
   ```
   mcp_render_list_logs with:
   - resource: [serviceId]
   - limit: 100
   - type: ["build"]
   - direction: "backward"
   ```

### 2. Common Deployment Issues to Check For

- **SyntaxError**: Variable redeclaration, missing brackets, etc.
- **Module errors**: Missing dependencies, import issues
- **Environment variables**: Missing required env vars
- **Build failures**: npm install errors, compilation issues

### 3. After Fixing Deployment Issues

1. Fix the code issue identified in logs
2. Run `npm run build` to update dist folder
3. Increment version (patch for bug fixes)
4. Commit with descriptive message mentioning the fix
5. Push to trigger new deployment
6. Monitor logs again to verify successful deployment

## Browser Testing Rules

### NEVER Test in Browser After Making Changes
- **DO NOT** use browser tools to test changes after implementing a feature
- The production site (clerkyai.health) requires authentication and deployment
- Changes only take effect after being pushed to Git and deployed to Render
- Browser testing will always fail because local changes are not reflected on the live site
- Simply inform the user that changes are ready and ask if they want to commit/deploy

## Best Practices

1. Always inform the user what files will be committed before committing
2. Use descriptive commit messages that follow conventional commits format when possible
3. When version incrementing, include relevant changes in the commit message
4. Remember: The user prefers British English spelling (analyse vs analyze, etc.)
5. Ask one question at a time when clarification is needed

## General Utility Rules

### 1. Always Prefer Grep
- ALWAYS use `grep` (via `grep_search` tool) instead of `findstr` for searching text in files
- The user prefers `grep` syntax and functionality over Windows `findstr`
- Only use `findstr` if specifically requested or if `grep` is absolutely unavailable (though `grep_search` is always available to you)

